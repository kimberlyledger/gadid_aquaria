---
title: "compositional data analyses - gadid aquaria metabarcoding"
output: html_document
date: "2024-03-11"
---

THIS CODE IS NOT BEING USED AT THE MOMENT>>>  just was exploratory... 


clear environment
```{r}
rm(list=ls())
```

```{r}
library(tidyverse)
library(ggplot2)
select <- dplyr::select
```

to first get a better handle on compostional data analyses, i'm going to run through some example code from "Analyzing Compositional Data with R".
this is from Chapter 5.4

```{r}
library(compositions)
```

```{r}
GeoChemSed=read.csv("gadid_mb_aquaria/GraVel.csv",header=TRUE)
Y=acomp(GeoChemSed[,7:10])
names(GeoChemSed)
compY <- acomp(Y[GeoChemSed$grain=="c",])
compX <- acomp(Y[GeoChemSed$grain=="m",])
dim(compY)
dim(compX)
```

5.4.2 - Visualization
```{r}
opar<-par(mar=c(4,4,0,0),oma=c(3,3,0.1,0.1))
pairwisePlot(clr(compX),clr(compY))
mtext(text=c("medium-sized","coarse"),side=c(1,2), at=0.5,line=2,outer=TRUE)
```

5.4.3 - composition-to-composition regression model
```{r}
modelCC <- lm(ilr(compY)~ilr(compX))
modelCC
anova(modelCC)
ilrInv(coef(modelCC)[1,],orig=compY)
```





## now it's time to work with aquaria data 

to follow the example code above, i need a matrix with true tank proportions (where each row is a tank and columns are spp proportions) and another matrix with qm read proportions


read in tank estimates
```{r}
tanks_long <- read.csv("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/tank_mock_estimates.csv") %>%
  mutate(Species = ifelse(Species == "Boreogadus saida", "AC", Species),
         Species = ifelse(Species == "Gadus chalcogrammus", "WP", Species),
         Species = ifelse(Species == "Gadus macrocephalus", "PC", Species))
```

```{r}
tanks_mb <- tanks_long %>%
  select(tank_ID:Mean) %>% ## note that i'm leaving behind variance estimates (sd's/confidence intervals) here 
  pivot_wider(names_from = Species, values_from = Mean) %>%
  select(tank_ID, AC, PC, WP, n.simple.N, n.sample.dissim, n.tank.dissim)
```


read in tank metadata 
```{r}
tank_biomass <-  read.csv("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/TankData_MBmodified.csv") %>% 
  filter(groupID != "T") %>%  #remove tap water controls
  select(!sampleID) %>% #remove sample id because estimates are at the tank-level
  unique() %>%
  rename(tank_ID = groupID)
```


join - this removes the few T tanks with eDNA reads - but we still have no fish tanks included 
```{r}
tanks_all <- tank_biomass %>%
  left_join(tanks_mb, by = "tank_ID") %>%
  mutate(AC = ifelse(is.na(AC), 0, AC),
         PC = ifelse(is.na(PC), 0, PC),
         WP = ifelse(is.na(WP), 0, WP)) %>%
  #mutate(AC_Fbiomass_comp = ifelse(AC_Fbiomass == 0, -Inf, AC_Fbiomass), 
  #       PC_Fbiomass_comp = ifelse(PC_Fbiomass == 0, -Inf, PC_Fbiomass),
  #       WP_Fbiomass_comp = ifelse(WP_Fbiomass == 0, -Inf, WP_Fbiomass),
  mutate(AC_Fbiomass_comp = AC_Fbiomass + 1e-10,
          PC_Fbiomass_comp = PC_Fbiomass + 1e-10,
            WP_Fbiomass_comp = WP_Fbiomass + 1e-10)
```


filter the dataframe based on tanks i want to restrict models to (i.e. remove tanks with high dissimilarity, etc)
```{r}
tanks_filtered <- tanks_all %>%
  filter(n.tank.dissim != "2") %>%
  filter(Fish_pres == "1")
```


create compositional matrices
```{r}
comp_biomass <- acomp(tanks_filtered[,c("AC_Fbiomass_comp","PC_Fbiomass_comp","WP_Fbiomass_comp")])
comp_mb <- acomp(tanks_filtered[,c("AC","PC","WP")])
dim(comp_biomass)
dim(comp_mb)
```

visualize
5.4.2 - Visualization
```{r}
opar<-par(mar=c(4,4,0,0),oma=c(3,3,0.1,0.1))
pairwisePlot(clr(comp_biomass),clr(comp_mb))
mtext(text=c("biomass","mb"),side=c(1,2), at=0.5,line=2,outer=TRUE)
```

i think just looking down the diagonal is informative here... 


composition-to-composition regression model  - not sure how to restrict to just AC to AC comparisons, etc... or if that matters... 
```{r}
model_tank <- lm(clr(comp_mb)~clr(comp_biomass))  #example was ilr 
model_tank
summary(model_tank)
anova(model_tank)
#ilrInv(coef(model_tank)[1,],orig=comp_mb)
#Bsvd <- svd( ilrvar2clr(coef(model_tank)[-1,]) )
```

```{r}
biomass_clr <- clr(comp_biomass)
mb_clr <- clr(comp_mb)

#arctic cod
plot(biomass_clr[,1] ~ mb_clr[,1])
ac_mod <- lm(biomass_clr[,1] ~ mb_clr[,1])
summary(ac_mod)

#pacific cod
plot(biomass_clr[,2] ~ mb_clr[,2])
pc_mod <- lm(biomass_clr[,2] ~ mb_clr[,2])
summary(pc_mod)

#walleye pollock
plot(biomass_clr[,3] ~ mb_clr[,3])
wp_mod <- lm(biomass_clr[,3] ~ mb_clr[,3])
summary(wp_mod)
```



okay, i'm thinking that it may be best to just avoid doing correlation tests and go with Aitchinson distance... 


# Start with a clean environment 
clear environment
```{r}
rm(list=ls())
```

load libraries
```{r}
library(tidyverse)
library(data.table)
library(gridExtra)
library(ggsci)
select <- dplyr::select
```

# read in tank metadata that has extractionIDs, altID, tankIDs, and species biomass proportions
```{r}
sample_metadata <- read.csv("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/gadid_aquariaDBO_metadata.csv") %>%
  filter(project == "aquaria") %>%
  select(!station_ID) %>%
  select(!location1:time_of_day) %>%
  select(!Sample_ID) %>%
  select(!pcr_replicate) %>%
  select(!project) 

#remove the samples from miseq run B that were also included in miseq run A (as i did during the data processing)
both_runs_extID <- c("e02362", "e02363", "e02366", "e02370", "e02372", "e02373", "e02374", "e02375", "e02380")

both_runs <- sample_metadata %>%
  filter(extraction_ID %in% both_runs_extID)

both_runs_A <- both_runs %>%
  filter(MiSeq_run == "A")

sample_metadata <- sample_metadata %>%
  filter(!extraction_ID %in% both_runs_extID) %>%
  bind_rows(both_runs_A) %>%
  rename(community = extraction_ID) %>%
  unique() %>%
  filter(sample_type == "sample")
```

read in tank metadata 
```{r}
tank_metadata <-  read.csv("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/TankData_MBmodified.csv") %>% 
  filter(groupID != "T") %>%  #remove tap water controls
  select(!sampleID) %>% #remove sample id because estimates are at the tank-level
  unique() %>%
  rename(tank_ID = groupID) %>%
  #add columns for species in mock communities but not included in tanks to be able to get code to run... 
  mutate(TomC_Fbiomass = 0) %>%
  mutate(PolarC_Fbiomass = 0) %>%
  mutate(SafC_Fbiomass = 0) %>%
  pivot_longer(cols = c(19:21, 32:34), names_to = "Species", values_to = "Fbiomass") %>%
  mutate(Species = str_remove(Species, "_Fbiomass")) %>%
  select(Species,Fbiomass,tank_ID)
```

join sample and tank metadata and change to scientific names to match models 
```{r}
community_prop <- sample_metadata %>%
  left_join(tank_metadata, by = "tank_ID") %>%
  mutate(Species = ifelse(Species == "AC", "Boreogadus saida", Species)) %>%
    mutate(Species = ifelse(Species == "PC", "zRefSpecies_Gadus macrocephalus", Species)) %>%
    mutate(Species = ifelse(Species == "WP", "Gadus chalcogrammus", Species)) %>%
    mutate(Species = ifelse(Species == "TomC", "Microgadus proximus", Species)) %>%
    mutate(Species = ifelse(Species == "PolarC", "Arctogadus glacialis", Species)) %>%
    mutate(Species = ifelse(Species == "SafC", "Eleginus gracilis", Species)) 
```


# Read in the stan model outputs of aquarium samples 
```{r}
load("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/quant_mb_outputs/raw_20231101.Rdata")
raw <- Output
load("/home/kimberly.ledger/gadid_aquaria/gadid_mb_aquaria/quant_mb_outputs/mock_20231102.Rdata")
mock1 <- Output 
```

```{r}
#########################################################
# Raw estimates from Reads
#########################################################

# start by adding true prop into raw$env object... 

# summarize raw estimates from reads for each species.
raw.raw <- raw$env %>%
  left_join(community_prop, by = c("Species", "community")) %>%
  mutate(true.prop = Fbiomass) %>%
  group_by(Species,community,Cycles,true.prop) %>%
  #group_by(Species,community,Cycles) %>%
  summarize(simple.Mean=mean(propReads),
            simple.N = length(tech_rep)) %>%
  replace_na(list(raw.Mean=0,raw.SD=0,raw.SE=0))

# extract predicted proportions from the posterior
COM <- data.frame(community = levels(raw$env$community %>% as.factor()))
COM$comm_idx <- 1:nrow(COM)
SP  <- raw$env %>% distinct(Species,sp_idx) %>% as.data.frame()

# These are the predicted intercepts for the posteriors
beta_posterior <- raw$stanMod_summary[["int_samp_small"]][, c(1,4:8)]
colnames(beta_posterior) <- paste0("raw.",substr(colnames(beta_posterior),1,nchar(colnames(beta_posterior))-1))
colnames(beta_posterior)[1] <- "raw.mean"
beta_posterior <- as.data.frame(beta_posterior)

raw.post <-expand.grid(comm_idx = COM$comm_idx,sp_idx =SP$sp_idx) %>% 
  arrange(comm_idx,sp_idx) %>% 
  left_join(.,COM) %>% 
  left_join(.,SP) %>% 
  bind_cols(.,beta_posterior)

# Combine the raw estimates and posterior estimates
raw.all <- full_join(raw.raw,raw.post)
```

```{r}
#########################################################
# Mock1
#########################################################
# summarize raw estimates from reads for each species.
mock1.raw <- mock1$env %>%
  left_join(community_prop, by = c("Species", "community")) %>%
  mutate(true.prop = Fbiomass) %>%
  group_by(Species,community,Cycles,true.prop) %>%
  summarize(simple.Mean=mean(propReads),
            simple.N = length(tech_rep)) %>%
  replace_na(list(raw.Mean=0,raw.SD=0,raw.SE=0))

# extract predicted proportions from the posterior
COM <- data.frame(community = levels(mock1$env$community %>% as.factor()))
COM$comm_idx <- 1:nrow(COM)
SP  <- mock1$env %>% distinct(Species,sp_idx) %>% as.data.frame()

# These are the predicted intercepts for the posteriors
beta_posterior <- mock1$stanMod_summary[["int_samp_small"]][, c(1,4:8)]
colnames(beta_posterior) <- paste0("mock1.",substr(colnames(beta_posterior),1,nchar(colnames(beta_posterior))-1))
colnames(beta_posterior)[1] <- "mock1.mean"
beta_posterior <- as.data.frame(beta_posterior)

mock1.post <-expand.grid(comm_idx = COM$comm_idx,sp_idx =SP$sp_idx) %>% 
    arrange(comm_idx,sp_idx) %>% 
    left_join(.,COM) %>% 
    left_join(.,SP) %>% 
    bind_cols(.,beta_posterior)

# Combine the raw estimates and posterior estimates
mock1.all <- full_join(mock1.raw,mock1.post)
```

```{r}
# Combine mock results with raw reads.
result.dat <- left_join(mock1.all,raw.all)
```


```{r}
####################################################33
# Calculate Aitchison Distance
####################################################33


# Aitchison distance
# Calculate for raw and mock

# Make containers for each type of output
make.cont <- function(dat){
  out <-  matrix(0,max(dat$comm_idx),max(dat$sp_idx))
  rownames(out) <- dat %>% distinct(community) %>% pull(community)
  colnames(out) <- dat %>% distinct(Species) %>% pull(Species)
  return(out)
}

raw.out <- make.cont(raw.post)
mock1.out <- make.cont(mock1.post)

raw.sp   <- data.frame(Species=raw.post %>% distinct(Species) %>% pull(Species))
raw.comm <- data.frame(community=raw.post %>% distinct(community) %>% pull(community))

mock.sp   <- data.frame(Species=mock1.post %>% distinct(Species) %>% pull(Species))
mock.comm <- data.frame(community=mock1.post %>% distinct(community) %>% pull(community))

# make true.matrix

true.mat <- community_prop %>% 
  select(c(Species, community, Fbiomass)) %>%
  pivot_wider(values_from = "Fbiomass", names_from = "Species") %>%
  as.data.frame() %>%
  select(c("community","Arctogadus glacialis", "Boreogadus saida", "Eleginus gracilis", "Gadus chalcogrammus", "Microgadus proximus", "zRefSpecies_Gadus macrocephalus"))

rownames(true.mat) <- true.mat$community
true.mat <-  true.mat %>% ungroup() %>% dplyr::select(-community)

#####################################################################   

# so i can't get robCompositions to install now so switching to another package... 
library(coda.base)

# loop over raw
raw.AD <- data.frame(matrix(0,dim(raw$pars$int_samp_small)[1],nrow(true.mat)))
colnames(raw.AD) <- rownames(true.mat)
for(i in 1:dim(raw$pars$int_samp_small)[1]){
 # raw.1 <- raw$pars$int_samp_small[i,,] %>% as.data.frame()
    raw.1 <- raw$pars$int_samp_small[1,,] %>% as.data.frame()
  rownames(raw.1) <- raw.comm$community 
  colnames(raw.1) <- raw.sp$Species
  raw.2 <- raw.1 %>% 
              filter(rownames(.) %in% result.dat$community)%>%
              dplyr::select(result.dat$Species) 
  
  for(j in 1:nrow(raw.2)){
    these <- which(true.mat[j,]>0)
    true <- true.mat[j,these]
    raw.3 <- raw.2[j,these] / sum(raw.2[j,these])
    
    #raw.AD[i,rownames(true.mat)[j]] <-  aDist(true,raw.3)
    raw.AD[i,rownames(true.mat)[j]] <-  dist(rbind(true,raw.3), method = "aitchison")
  }
  #print(i)
}

# loop over mock1
mock1.AD <- data.frame(matrix(0,dim(mock1$pars$int_samp_small)[1],nrow(true.mat)))
colnames(mock1.AD) <- rownames(true.mat)
for(i in 1:dim(mock1$pars$int_samp_small)[1]){
  mock.a <- mock1$pars$int_samp_small[i,,] %>% as.data.frame()
  rownames(mock.a) <- mock.comm$community 
  colnames(mock.a) <- mock.sp$Species
  mock.b <- mock.a %>% 
    filter(rownames(.) %in% result.dat$community)%>%
    dplyr::select(result.dat$Species) 
  
  for(j in 1:nrow(mock.b)){
    these <- which(true.mat[j,]>0)
    true <- true.mat[j,these]
    mock.c <- mock.b[j,these] / sum(mock.b[j,these])
    
    #mock1.AD[i,rownames(true.mat)[j]] <-  aDist(true,mock.c)
    mock1.AD[i,rownames(true.mat)[j]] <-  dist(rbind(true,mock.c), method = "aitchison")
  }
  #print(i)
}

raw.AD$model <- "raw"
mock1.AD$model <- "mock1"

all.AD <- bind_rows(raw.AD,mock1.AD)

all.AD <- all.AD %>% 
              pivot_longer(.,-model,
                           names_to="community",
                           values_to = "val")
all.AD.sum <- all.AD %>% group_by(model,community) %>% 
                summarize(Mean = mean(val),
                          SD=sd(val),
                          q.025 = quantile(val,probs=0.025),
                          q.05 = quantile(val,probs=0.05),
                          q.25 = quantile(val,probs=0.25),
                          q.75 = quantile(val,probs=0.75),
                          q.95 = quantile(val,probs=0.95),
                          q.975 = quantile(val,probs=0.975))  %>%
                ungroup() %>%
                mutate(offset.plot = 0,
                       offset.plot = ifelse(model=="raw",-0.05,offset.plot)) %>%
                mutate(Calibration = case_when(model=="raw"~"None",
                             model=="mock1"~"Mock")) %>%
                as.data.frame()

all.AD.sum$comm.idx = as.numeric(as.factor(all.AD.sum$community))
                


xBREAKS <- all.AD.sum %>% distinct(comm.idx,community)
yBREAKS <- c(0,1,2,3,4,5)

col.val <- pal_jco(palette = c("default"), alpha = 1)(10)[c(6,7)]

p_AD <- ggplot(all.AD.sum) + # %>% 
          geom_errorbar(aes(x=comm.idx + offset.plot,ymin=q.025,ymax=q.975,color=Calibration),width=0) +
          geom_errorbar(aes(x=comm.idx + offset.plot,ymin=q.25,ymax=q.75,color=Calibration),size=2,width=0) +        
          geom_point(aes(x=comm.idx + offset.plot,y=Mean,color=Calibration),shape =21,fill="white",size=2) +
          #scale_y_continuous(NULL,expand=c(0,NA),limits=c(0,NA),breaks=yBREAKS) +
          #scale_shape_manual(values=c(21,22,24)) +
          scale_fill_manual(values=col.val,"Community") +
          scale_color_manual(values=col.val,"Calibration") +
          scale_x_continuous(NULL,breaks=xBREAKS$comm.idx,labels=xBREAKS$community,limits=c(NA,5.3)) +
          ylab("Aitchison distance") +
          theme_classic() +
          theme(legend.position = c(0.4755,0.85),
                plot.margin = margin(0,0,0,0.85,"lines"),
                legend.key.size=unit(0.1,'lines'),
                legend.text=element_text(size=7),
                legend.title=element_text(size=9))
          
p_AD


#ggsave(p_AD, filename = "/home/kimberly.ledger/gadid_metabarcoding/mock_community/mockcom_comparison/gadid_even_aitchison.jpg", width = 6, height = 5, units = "in")
```

